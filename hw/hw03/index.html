<!DOCTYPE html>
<html lang="en">

<head>
  <meta name="description" content="CS 61A: Structure and Interpretation of Computer Programs" />
  <meta name="keywords" content="CS 61A, Computer Science, CS, 61A, Programming, John DeNero, Berkeley, EECS" />
  <meta name="author" content="Hany Farid, John DeNero" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="../../assets/js/hl.js"></script>
  <script>
    // we aren't registering builtins since
    //      (1) they don't render differently in the current CSS from other names
    //      (2) it's a mess to list all of them. You can extract from the site but that takes effort
    // if (1) ceases to be true, (2) might be worth the effort. For now, we're leaving as is
    hljsRegister({
      'keyword': "define if cond and or let begin lambda mu quote delay cons-stream set! quasiquote unquote unquote-splicing define-macro"
    });
    hljs.initHighlightingOnLoad();
  </script>
  <script src="../../assets/js/dark-mode.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=Inconsolata|Roboto:300,400,500|Work+Sans:400,700">
  <link rel="stylesheet" href="../../assets/css/style.css">
  <link rel="stylesheet" href="../../assets/css/mono-blue.css">
  <link rel="icon" href="../../assets/images/favicon.ico">



  <link rel="stylesheet" type="text/css" href="../../assets/css/hw.css">


  <title>
    Homework 3 | CS 61A Fall 2020
  </title>
</head>

<body id="index" class="home">
  <nav class="navbar navbar-default navbar-static-top">
    <div class="container noselect">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
          data-target="#navbar-collapse-section">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../">
          <img style="max-width:60px; margin-top: -20px;" class="logo" src="../../assets/images/logo.png" />
        </a>
      </div>

      <div class="collapse navbar-collapse" id="navbar-collapse-section">
        <ul class="nav navbar-nav navbar-right">
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown"
              aria-haspopup="true" aria-expanded="false">
              Staff
            </a>
            <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              <li><a href="../../instructor.html">Instructors</a></li>
              <li><a href="../../TAs.html">TAs</a></li>
              <li><a href="../../tutors.html">Tutors</a></li>
            </ul>
          </li>
          <li><a href="../../resources.html">Resources</a></li>
          <li><a href="../../articles/about.html">Syllabus</a></li>
          <li><a href="https://code.cs61a.org">Code</a></li>
          <li><a href="http://tutor.cs61a.org" target="_blank">Tutor</a></li>
          <li>
            <a style="color:white; font-size: 15px;vertical-align: middle" href="https://github.com/ChillyHigh/CS61A-CN"
              title="前往仓库" target="_blank">
              <img height="21px" src="https://cdn.jsdelivr.net/npm/simple-icons@v9/icons/github.svg" alt="GitHub"
                style="filter: invert(1) brightness(1000%);">
              <span style="vertical-align: middle;padding-left: 0.5rem;"> CS61A-CN</span>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <main id="content" class="container">

    <div class='row'>
      <div class='col-md-9'>
        <header>
          <h1>

            作业3: 树, 数据抽象
            <br>
            <small>
              Homework 3: Trees, Data Abstraction
            </small>

            <br>
            <ul class="inline-block list-inline">
              <li><a href="hw03.zip" class="label label-outline">hw03.zip</a></li>
            </ul>


          </h1>
        </header>


        <p><em>Due by 11:59pm on Thursday, October 8</em></p>



        <h3><a href="EN.html">查看英文原文</a></h3>

        <h2>说明</h2>

        <p>下载 <a href="hw03.zip">hw03.zip</a>。在压缩包中，你会找到一个名为 <a href="hw03.py">hw03.py</a> 的文件，以及一份 <code>ok</code>
          自动评分器。</p>

        <p><strong>提交：</strong>完成后使用<code>python3 ok
            --submit</code>来提交代码。你可以在截止日期前多次提交；只有最后一次提交会被评分。请检查你是否成功提交了代码到<a
            href="https://okpy.org/">okpy.org</a>。更多提交作业的说明请参见<a
            href="../../lab/lab00#submitting-the-assignment">Lab0</a>。</p>
        <p><strong>使用Ok:</strong>如果你对使用Ok有任何疑问，请参考<a href="../../articles/using-ok.html">本指南</a>。</p>

        <p><strong>阅读材料：</strong>以下阅读材料可能对你有帮助</p>
        <ul>
          <li><a href="https://composingprograms.netlify.app/1/7">Section 1.7</a></li>
          <li><a href="https://composingprograms.netlify.app/2/3">Section 2.3</a></li>
        </ul>


        <p><strong>评分：</strong>作业评分基于正确性。每个错误的问题将使总分减少一分。课程大纲中有作业恢复政策。
          <strong>本次作业满分为2分。</strong>
        </p>

        <h1 id="required-questions">必答题</h1>


        <br />

        <p>观看下面的提示视频来获得一些初步的指导:

          <iframe width="560" height="315"
            src="//player.bilibili.com/player.html?isOutside=true&aid=427281261&bvid=BV1s3411G7yM&cid=760052457&p=37&autoplay=0"
            scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" autoplay=0></iframe>
        </p>
        <br />


        <h2 id="abstraction">抽象 (Abstraction)</h2>

        <h2 id="mobiles">悬挂模型</h2>

        <p><strong>致谢。</strong> 这个悬挂模型示例来自 MIT 经典教材《计算机程序的构造和解释》中的一个经典问题，详见
          <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.2">第
            2.2.2 节</a>。
        </p>

        <p><img class="img-responsive center-block" src="assets/mobile-planet.png" alt="悬挂模型示例"></p>

        <p>我们正在制作一个天文馆的悬挂模型。一个<a
            href="https://images.zanui.com.au/unsafe/1600x/filters:sharpen(1,0.2,1):quality(80)/production-static.aws.zanui.com.au/p/authentic-models-0459-1.jpg">悬挂模型</a>是一种悬挂式雕塑。二叉悬挂模型由两条悬臂组成。每条悬臂是一根具有特定长度的杆子，其末端悬挂着一个行星或另一个悬挂模型。例如，下图展示了悬挂模型
          A 的左臂和右臂，以及它们各自末端所悬挂的内容。</p>

        <p><img class="img-responsive center-block" src="assets/mobile-planet-labeled.png" alt="标注的悬挂模型示例"></p>

        <p>我们将使用以下数据抽象来表示二叉悬挂模型：</p>

        <ul>
          <li>一个 <code>mobile</code>（悬挂模型）必须具有左 <code>arm</code>（悬臂）和右 <code>arm</code>（悬臂）。</li>
          <li>一个 <code>arm</code>（悬臂）具有正长度，并且必须在末端悬挂某物，可以是另一个 <code>mobile</code>（悬挂模型）或 <code>planet</code>（行星）。</li>
          <li>一个 <code>planet</code>（行星）具有正大小，并且没有任何其他物体悬挂在其上。</li>
        </ul>

        <h3 id="arms-length-recursion-sidenote">悬臂长度递归（附注）</h3>

        <p>在开始之前，先对树形数据结构的递归做一个简要说明。请考虑以下函数。</p>


        <pre><code>def min_depth(t):
    &quot;&quot;&quot;A simple function to return the distance between t&#x27;s root and its closest leaf&quot;&quot;&quot;
    if is_leaf(t):
        return 0 # Base case&#x2d;&#x2d;&#x2d;the distance between a node and itself is zero
    h = float(&#x27;inf&#x27;) # Python&#x27;s version of infinity
    for b in branches(t):
        if is_leaf(b): return 1 # !!!
        h = min(h, 1 + min_depth(b))
    return h</code></pre>

        <p>标注有 <code>!!!</code> 的那一行违反了“悬臂长度”递归原则。虽然这段代码在存在该行时仍然能够正确运行，但实际上，我们在这里执行的检查应该由递归的下一级来完成。我们已经在
          <code>min_depth</code> 函数中使用了 if 语句来处理叶子节点的输入，因此不应该再包含这行代码，以避免代码的冗余。
        </p>

        <pre><code>def min_depth(t):
    &quot;&quot;&quot;A simple function to return the distance between t&#x27;s root and its closest leaf&quot;&quot;&quot;
    if is_leaf(t):
        return 0
    h = float(&#x27;inf&#x27;)
    for b in branches(t):
        # Still works fine!
        h = min(h, 1 + min_depth(b))
    return h</code></pre>

        <p>
          “悬臂长度”递归不仅会导致代码冗余，还会使代码更加复杂，并掩盖递归函数的实际功能，从而增加编写递归函数的难度。我们希望递归情况仅处理一个递归层级，而不是进行额外的检查。我们可能会在某些情况下检查你的代码是否存在类似问题。
        </p>

        <h3 class="question" id="q1">Q1: 重量</h3>

        <p>通过完成 <code>planet</code> 构造函数和 <code>size</code> 选择器来实现 <code>planet</code>
          数据抽象，使得一个行星可以用一个包含两个元素的列表表示，其中第一个元素是字符串 <code>&#x27;planet&#x27;</code>，第二个元素是它的大小。
          <code>total_weight</code> 示例展示了如何使用悬挂模型、悬臂和行星的抽象。
        </p>

        <pre><code>def mobile(left, right):
    &quot;&quot;&quot;Construct a mobile from a left arm and a right arm.&quot;&quot;&quot;
    assert is_arm(left), &quot;left must be a arm&quot;
    assert is_arm(right), &quot;right must be a arm&quot;
    return [&#x27;mobile&#x27;, left, right]

def is_mobile(m):
    &quot;&quot;&quot;Return whether m is a mobile.&quot;&quot;&quot;
    return type(m) == list and len(m) == 3 and m[0] == &#x27;mobile&#x27;

def left(m):
    &quot;&quot;&quot;Select the left arm of a mobile.&quot;&quot;&quot;
    assert is_mobile(m), &quot;must call left on a mobile&quot;
    return m[1]

def right(m):
    &quot;&quot;&quot;Select the right arm of a mobile.&quot;&quot;&quot;
    assert is_mobile(m), &quot;must call right on a mobile&quot;
    return m[2]</code></pre>

        <!-- hack -->

        <pre><code>def arm(length, mobile_or_planet):
    &quot;&quot;&quot;Construct a arm: a length of rod with a mobile or planet at the end.&quot;&quot;&quot;
    assert is_mobile(mobile_or_planet) or is_planet(mobile_or_planet)
    return [&#x27;arm&#x27;, length, mobile_or_planet]

def is_arm(s):
    &quot;&quot;&quot;Return whether s is a arm.&quot;&quot;&quot;
    return type(s) == list and len(s) == 3 and s[0] == &#x27;arm&#x27;

def length(s):
    &quot;&quot;&quot;Select the length of a arm.&quot;&quot;&quot;
    assert is_arm(s), &quot;must call length on a arm&quot;
    return s[1]

def end(s):
    &quot;&quot;&quot;Select the mobile or planet hanging at the end of a arm.&quot;&quot;&quot;
    assert is_arm(s), &quot;must call end on a arm&quot;
    return s[2]</code></pre>

        <!-- hack -->

        <pre><code>def planet(size):
    &quot;&quot;&quot;Construct a planet of some size.&quot;&quot;&quot;
    assert size &gt; 0
    "*** YOUR CODE HERE ***"

def size(w):
    &quot;&quot;&quot;Select the size of a planet.&quot;&quot;&quot;
    assert is_planet(w), &#x27;must call size on a planet&#x27;
    "*** YOUR CODE HERE ***"

def is_planet(w):
    &quot;&quot;&quot;Whether w is a planet.&quot;&quot;&quot;
    return type(w) == list and len(w) == 2 and w[0] == &#x27;planet&#x27;</code></pre>

        <!-- hack -->

        <pre><code>def total_weight(m):
    &quot;&quot;&quot;Return the total weight of m, a planet or mobile.

    &gt;&gt;&gt; t, u, v = examples()
    &gt;&gt;&gt; total_weight(t)
    3
    &gt;&gt;&gt; total_weight(u)
    6
    &gt;&gt;&gt; total_weight(v)
    9
    &gt;&gt;&gt; from construct_check import check
    &gt;&gt;&gt; # checking for abstraction barrier violations by banning indexing
    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;total_weight&#x27;, [&#x27;Index&#x27;])
    True
    &quot;&quot;&quot;
    if is_planet(m):
        return size(m)
    else:
        assert is_mobile(m), &quot;must get total weight of a mobile or a planet&quot;
        return total_weight(end(left(m))) + total_weight(end(right(m)))</code></pre>

        <p>使用 Ok 来测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q total_weight --local</code></pre>

        <h3 class="question" id="q2">Q2: 平衡性</h3>

        <p>实现 <code>balanced</code> 函数，该函数用于判断 <code>m</code> 是否是一个平衡的 <code>mobile</code>（悬挂结构）。一个 <code>mobile</code>
          在以下两种条件都满足时被认为是平衡的：</p>

        <ol>
          <li>其左侧支臂施加的力矩应等于右侧支臂施加的力矩。
            左侧支臂的力矩等于左侧杆的长度乘以该杆上悬挂物体的总重量，右侧同理。
            例如，如果左侧支臂的长度为 <code>5</code>，且左侧悬挂着一个重量为 <code>10</code> 的 <code>mobile</code>，
            则左侧的力矩为 <code>50</code>。
          </li>
          <li>悬挂在支臂末端的所有 <code>mobile</code> 也必须是平衡的。</li>
        </ol>

        <p>行星（planets）本身是平衡的，因为它们没有任何悬挂物。</p>

        <pre><code>def balanced(m):
    &quot;&quot;&quot;Return whether m is balanced.

    &gt;&gt;&gt; t, u, v = examples()
    &gt;&gt;&gt; balanced(t)
    True
    &gt;&gt;&gt; balanced(v)
    True
    &gt;&gt;&gt; w = mobile(arm(3, t), arm(2, u))
    &gt;&gt;&gt; balanced(w)
    False
    &gt;&gt;&gt; balanced(mobile(arm(1, v), arm(1, w)))
    False
    &gt;&gt;&gt; balanced(mobile(arm(1, w), arm(1, v)))
    False
    &gt;&gt;&gt; from construct_check import check
    &gt;&gt;&gt; # checking for abstraction barrier violations by banning indexing
    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;balanced&#x27;, [&#x27;Index&#x27;])
    True
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"
</code></pre>

        <p>使用 Ok 来测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q balanced --local</code></pre>



        <h3 class="question" id="q3">Q3: 总重量</h3>

        <p>实现 <code>totals_tree</code> 函数，该函数接受一个 <code>mobile</code>（或 <code>planet</code>），
          并返回一个 <code>tree</code>，其根节点的值为输入对象的总重量。
          对于 <code>planet</code>，<code>totals_tree</code> 应返回一个叶子节点。
          对于 <code>mobile</code>，<code>totals_tree</code> 应返回一个以该 <code>mobile</code> 的总重量为标签的树，
          其分支为该 <code>mobile</code> 的两个支臂末端对应的 <code>totals_tree</code>。
        </p>

        <pre><code>def totals_tree(m):
    &quot;&quot;&quot;Return a tree representing the mobile with its total weight at the root.

    &gt;&gt;&gt; t, u, v = examples()
    &gt;&gt;&gt; print_tree(totals_tree(t))
    3
      2
      1
    &gt;&gt;&gt; print_tree(totals_tree(u))
    6
      1
      5
        3
        2
    &gt;&gt;&gt; print_tree(totals_tree(v))
    9
      3
        2
        1
      6
        1
        5
          3
          2
    &gt;&gt;&gt; from construct_check import check
    &gt;&gt;&gt; # checking for abstraction barrier violations by banning indexing
    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;totals_tree&#x27;, [&#x27;Index&#x27;])
    True
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"
</code></pre>

        <p>使用 Ok 来测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q totals_tree --local</code></pre>


        <h2 id="trees">树 (Trees)</h2>

        <h3 class="question" id="q4">Q4: 替换叶子 (Replace Leaf)</h3>

        <p>定义 <code>replace_leaf</code> 函数，该函数接受一棵树 <code>t</code>、一个待查找的值 <code>find_value</code>，以及一个替换值
          <code>replace_value</code>。
          <code>replace_leaf</code> 返回一棵新树，该树与 <code>t</code> 相同，但所有等于 <code>find_value</code> 的叶子标签都被替换为
          <code>replace_value</code>。
        </p>

        <solution>

          <pre><code>def replace_leaf(t, find_value, replace_value):
    &quot;&quot;&quot;Returns a new tree where every leaf value equal to find_value has
    been replaced with replace_value.

    &gt;&gt;&gt; yggdrasil = tree(&#x27;odin&#x27;,
    ...                  [tree(&#x27;balder&#x27;,
    ...                        [tree(&#x27;thor&#x27;),
    ...                         tree(&#x27;freya&#x27;)]),
    ...                   tree(&#x27;frigg&#x27;,
    ...                        [tree(&#x27;thor&#x27;)]),
    ...                   tree(&#x27;thor&#x27;,
    ...                        [tree(&#x27;sif&#x27;),
    ...                         tree(&#x27;thor&#x27;)]),
    ...                   tree(&#x27;thor&#x27;)])
    &gt;&gt;&gt; laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes
    &gt;&gt;&gt; print_tree(replace_leaf(yggdrasil, &#x27;thor&#x27;, &#x27;freya&#x27;))
    odin
      balder
        freya
        freya
      frigg
        freya
      thor
        sif
        freya
      freya
    &gt;&gt;&gt; laerad == yggdrasil # Make sure original tree is unmodified
    True
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"
</code></pre>

        </solution>

        <!--
<br />

<p>Watch the hints video below for somewhere to start:

            <iframe width="560" height="315" src="https://youtube.com/embed/FUIXaJaReOA"
                frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe></p>

<br />
-->

        <p>使用 Ok 来测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q replace_leaf --local</code></pre>

        <!--

-->

        <h3 class="question" id="q5">Q5: 前序遍历 (Preorder)</h3>

        <p>定义函数 <code>preorder</code>，该函数以一棵树作为参数，并返回一个列表，
          其中包含树中所有节点的值，排列顺序与 <code>print_tree</code> 打印它们的顺序相同。
        </p>

        <p>下图展示了节点的打印顺序，箭头表示函数调用的顺序。</p>

        <p><img class="img-responsive center-block" src="assets/preorder.png" alt="前序遍历"></p>

        <blockquote>
          <p><em>注意</em>：这种遍历树的顺序称为前序遍历（preorder traversal）。</p>
        </blockquote>


        <solution>

          <pre><code>def preorder(t):
    &quot;&quot;&quot;Return a list of the entries in this tree in the order that they
    would be visited by a preorder traversal (see problem description).

    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
    &gt;&gt;&gt; preorder(numbers)
    [1, 2, 3, 4, 5, 6, 7]
    &gt;&gt;&gt; preorder(tree(2, [tree(4, [tree(6)])]))
    [2, 4, 6]
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"
</code></pre>

        </solution>

        <!--
<br />

<p>Watch the hints video below for somewhere to start:

            <iframe width="560" height="315" src="https://youtube.com/embed/4UHhxiynpmk"
                frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe></p>

<br />
-->

        <p>使用 Ok 来测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q preorder --local</code></pre>

        <h3 class="question" id="q6">Q6: 路径匹配 (Has Path)</h3>

        <p>编写函数 <code>has_path</code>，该函数接受一棵树 <code>t</code> 和一个字符串 <code>word</code>。
          如果存在一条从根节点开始的路径，使得路径上的节点标签依次拼出 <code>word</code>，则返回 <code>True</code>，否则返回 <code>False</code>。
          （这种数据结构被称为 <strong>字典树（trie）</strong>，它有很多有趣的应用，比如<strong>自动补全</strong>）。
          你可以假设树中每个节点的 <code>label</code> 恰好是一个字符。
        </p>


        <solution>

          <pre><code>def has_path(t, word):
    &quot;&quot;&quot;Return whether there is a path in a tree where the entries along the path
    spell out a particular word.

    &gt;&gt;&gt; greetings = tree(&#x27;h&#x27;, [tree(&#x27;i&#x27;),
    ...                        tree(&#x27;e&#x27;, [tree(&#x27;l&#x27;, [tree(&#x27;l&#x27;, [tree(&#x27;o&#x27;)])]),
    ...                                   tree(&#x27;y&#x27;)])])
    &gt;&gt;&gt; print_tree(greetings)
    h
      i
      e
        l
          l
            o
        y
    &gt;&gt;&gt; has_path(greetings, &#x27;h&#x27;)
    True
    &gt;&gt;&gt; has_path(greetings, &#x27;i&#x27;)
    False
    &gt;&gt;&gt; has_path(greetings, &#x27;hi&#x27;)
    True
    &gt;&gt;&gt; has_path(greetings, &#x27;hello&#x27;)
    True
    &gt;&gt;&gt; has_path(greetings, &#x27;hey&#x27;)
    True
    &gt;&gt;&gt; has_path(greetings, &#x27;bye&#x27;)
    False
    &quot;&quot;&quot;
    assert len(word) &gt; 0, &#x27;no path for empty word.&#x27;
    "*** YOUR CODE HERE ***"
</code></pre>

        </solution>

        <!--
<br />

<p>Watch the hints video below for somewhere to start:

            <iframe width="560" height="315" src="https://youtube.com/embed/KBaK9EmWusc"
                frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe></p>

<br />
-->

        <p>使用 Ok 来测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q has_path --local</code></pre>


        <h2 id="submit">Submit</h2>


        <p>Make sure to submit this assignment by running:</p>

        <pre><code>python3 ok &#x2d;&#x2d;submit</code></pre>


        <h1 id="extra-questions">附加题</h1>


        <h3 class="question" id="q7">Q7: 区间抽象 (Interval Abstraction)</h3>

        <p>Alyssa 的程序尚未完成，因为她尚未指定区间抽象的实现。
          她已经为你实现了构造函数；请补全选择器（selectors）的实现。
        </p>

        <pre><code>def interval(a, b):
    &quot;&quot;&quot;Construct an interval from a to b.&quot;&quot;&quot;
    return [a, b]

def lower_bound(x):
    &quot;&quot;&quot;Return the lower bound of interval x.&quot;&quot;&quot;
    "*** YOUR CODE HERE ***"

def upper_bound(x):
    &quot;&quot;&quot;Return the upper bound of interval x.&quot;&quot;&quot;
    "*** YOUR CODE HERE ***"
</code></pre>

        <p>使用 Ok 来解锁并测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q interval -u --local
python3 ok -q interval --local</code></pre>

        <p>Louis Reasoner 还提供了一个区间乘法的实现。但要注意：他的代码存在一些数据抽象违规问题，
          请在问题变成一场“火龙卷”之前帮他修复：
          <a href='https://www.bilibili.com/video/BV18x411i7dj/'>https://www.bilibili.com/video/BV18x411i7dj/</a>
        </p>

        <pre><code>def mul_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the product of any value in x and any
    value in y.&quot;&quot;&quot;
    p1 = x[0] * y[0]
    p2 = x[0] * y[1]
    p3 = x[1] * y[0]
    p4 = x[1] * y[1]
    return [min(p1, p2, p3, p4), max(p1, p2, p3, p4)]</code></pre>

        <p>使用 Ok 来解锁并测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q mul_interval -u
python3 ok -q mul_interval</code></pre>



        <h3 class="question" id="q8">Q8: 区间减法 (Sub Interval)</h3>

        <p>参考 Alyssa 的推理方式，实现一个用于区间的减法函数。
          如果发现自己在重复代码，尽量复用已有的函数。</p>

        <pre><code>def sub_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the difference between any value in x
    and any value in y.&quot;&quot;&quot;
    "*** YOUR CODE HERE ***"
</code></pre>

        <p>使用 Ok 来解锁并测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q sub_interval -u --local
python3 ok -q sub_interval --local</code></pre>


        <h3 class="question" id="q9">Q9: 区间除法 (Div Interval)</h3>

        <p>Alyssa 通过乘以 <code>y</code> 的倒数来实现了区间除法。
          但是，专家级系统程序员 Ben Bitdiddle 看了一眼后指出，
          如果除数区间跨越零，除法的意义就变得不清楚了。
          请在 Alyssa 的代码中添加一个 <code>assert</code> 语句，以确保不会使用包含零的区间作为除数：
        </p>

        <pre><code>def div_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the quotient of any value in x divided by
    any value in y. Division is implemented as the multiplication of x by the
    reciprocal of y.&quot;&quot;&quot;
    "*** YOUR CODE HERE ***"
    reciprocal_y = interval(1/upper_bound(y), 1/lower_bound(y))
    return mul_interval(x, reciprocal_y)</code></pre>

        <p>使用 Ok 来解锁并测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q div_interval -u --local
python3 ok -q div_interval --local</code></pre>



        <h3 class="question" id="q10">Q10: 并联电阻计算差异 (Par Diff)</h3>

        <p>经过大量努力，Alyssa P. Hacker 终于完成了她的系统。
          数年后，当她早已将其忘得一干二净时，突然接到了用户 Lem E. Tweakit 的狂怒电话。
          原来，Lem 发现 <a href="https://en.wikipedia.org/wiki/Series_and_parallel_circuits#Resistors_2">
            并联电阻的计算公式</a> 可以用两种代数等价的方式表示：
        </p>

        <pre><code>par1(r1, r2) = (r1 * r2) / (r1 + r2)</code></pre>

        <p>或者</p>

        <pre><code>par2(r1, r2) = 1 / (1/r1 + 1/r2)</code></pre>

        <p>他编写了以下两个程序，它们分别使用不同的方法计算
          <code>并联电阻</code> 公式：
        </p>

        <pre><code>def par1(r1, r2):
    return div_interval(mul_interval(r1, r2), add_interval(r1, r2))

def par2(r1, r2):
    one = interval(1, 1)
    rep_r1 = div_interval(one, r1)
    rep_r2 = div_interval(one, r2)
    return div_interval(one, add_interval(rep_r1, rep_r2))</code></pre>

        <p>Lem 抱怨说，Alyssa 的程序在这两种计算方式下得到了不同的结果，
          这可是个严重的问题。</p>

        <p>请证明 Lem 是对的。尝试在不同的算术表达式上测试系统的行为，
          创建一些区间 <code>r1</code> 和 <code>r2</code>，并展示 <code>par1</code> 和 <code>par2</code>
          确实可能产生不同的结果。</p>

        <pre><code>def check_par():
    &quot;&quot;&quot;Return two intervals that give different results for parallel resistors.

    &gt;&gt;&gt; r1, r2 = check_par()
    &gt;&gt;&gt; x = par1(r1, r2)
    &gt;&gt;&gt; y = par2(r1, r2)
    &gt;&gt;&gt; lower_bound(x) != lower_bound(y) or upper_bound(x) != upper_bound(y)
    True
    &quot;&quot;&quot;
    r1 = interval(1, 1) # Replace this line!
    r2 = interval(1, 1) # Replace this line!
    return r1, r2</code></pre>

        <p>使用 Ok 来测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q check_par --local</code></pre>



        <h3 class="question" id="q11">Q11: 多重引用问题 (Multiple References)</h3>

        <p>另一位用户 Eva Lu Ator 也注意到，不同但代数等价的表达式计算出来的区间不同。
          她说问题出在对同一个区间的多重引用上。</p>

        <p>多重引用问题：使用 Alyssa 系统进行区间计算的公式，如果能够写成一种形式，
          使得没有任何表示不确定数字的变量被重复引用，那么它的误差将更小。</p>

        <p>因此，她认为 <code>par2</code> 比 <code>par1</code> 更适合用于并联电阻的计算（参见 Q10：Par Diff 了解这两个函数！）。
          她是对的吗？为什么？请写一个函数返回一个包含你答案的字符串：</p>

        <p>提示：要创建一个多行字符串，必须使用三引号
          <code>&quot;&quot;&quot; like this &quot;&quot;&quot;</code>.
        </p>

        <pre><code>def multiple_references_explanation():
    return &quot;&quot;&quot;The multiple reference problem...&quot;&quot;&quot;
</code></pre>



        <h3 class="question" id="q12">Q12: 二次函数 (Quadratic)</h3>

        <p>编写一个函数 <code>quadratic</code>，返回一个
          <a href="http://en.wikipedia.org/wiki/Quadratic_function">二次函数</a>
          <code>f(t)</code> 在区间 <code>x</code> 上的值域：
        </p>

        <pre><code>f(t) = a*t*t + b*t + c</code></pre>

        <p>确保你的实现返回的区间最小，
          一个不会有多重引用问题的区间。</p>

        <p><em>提示</em>：二次函数的导数 <code>f&#x27;(t) = 2*a*t + b</code>，因此二次函数的极值点为 <code>&#x2d;b/(2*a)</code>：</p>

        <pre><code>def quadratic(x, a, b, c):
    &quot;&quot;&quot;Return the interval that is the range of the quadratic defined by
    coefficients a, b, and c, for domain interval x.

    &gt;&gt;&gt; str_interval(quadratic(interval(0, 2), &#x2d;2, 3, &#x2d;1))
    &#x27;&#x2d;3 to 0.125&#x27;
    &gt;&gt;&gt; str_interval(quadratic(interval(1, 3), 2, &#x2d;3, 1))
    &#x27;0 to 10&#x27;
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"
</code></pre>

        <p>使用 Ok 来测试你的代码：</p>
        <pre><code class="nohighlight">python3 ok -q quadratic --local</code></pre>



        <script>
          $('.alwaystoggle').css('display', 'inline-block');
          $('.alwaystoggle').click(function () {
            var solution_id = $(this).attr('id');
            $('div.' + solution_id).slideToggle(600);
          });
        </script>


      </div>

      <div class='col-md-3 sticky'>
        <nav class='hidden-print hidden-sm hidden-xs sidebar'>
          <ul>
            <li><a href="#instructions">说明</a></li>
            <li><a href="#required-questions">必答题</a></li>
            <ul>
              <li><a href="#abstraction">抽象 (Abstraction)</a></li>
              <li><a href="#mobiles">悬挂模型</a></li>
              <ul>
                <li><a href="#arms-length-recursion-sidenote">悬臂长度递归（附注）</a></li>
                <li><a href="#q1">Q1: 重量</a></li>
                <li><a href="#q2">Q2: 平衡性</a></li>
                <li><a href="#q3">Q3: 总重量</a></li>
              </ul>
              <li><a href="#trees">树 (Trees)</a></li>
              <ul>
                <li><a href="#q4">Q4: 替换叶子 (Replace Leaf)</a></li>
                <li><a href="#q5">Q5: 前序遍历 (Preorder)</a></li>
                <li><a href="#q6">Q6: 路径匹配 (Has Path)</a></li>
              </ul>
              <li><a href="#submit">Submit</a></li>
            </ul>
            <li><a href="#extra-questions">附加题</a></li>
            <ul>
              <li><a href="#q7">Q7: 区间抽象 (Interval Abstraction)</a></li>
              <li><a href="#q8">Q8: 区间减法 (Sub Interval)</a></li>
              <li><a href="#q9">Q9: 区间除法 (Div Interval)</a></li>
              <li><a href="#q10">Q10: 并联电阻计算差异 (Par Diff)</a></li>
              <li><a href="#q11">Q11: 多重引用问题 (Multiple References)</a></li>
              <li><a href="#q12">Q12: 二次函数 (Quadratic)</a></li>
            </ul>
          </ul>
        </nav>
      </div>
    </div>

  </main>

  <footer class="container">
    <div class="row text-center">
      <div class="col col-sm-4">
        <h3><a href="../../">CS 61A</a></h3>
        <ul class="nav nav-pills nav-stacked">
          <li><a href="../../weekly.html">Weekly Schedule</a></li>
          <li><a href="../../office-hours.html">Office Hours</a></li>
          <li><a href="../../staff.html">Staff</a></li>
        </ul>
      </div>
      <div class="col col-sm-4">
        <h3><a href="../../resources.html">Resources</a></h3>
        <ul class="nav nav-pills nav-stacked">
          <li><a href="../../articles/studying.html">Studying Guide</a></li>
          <li><a href="../../articles/debugging.html">Debugging Guide</a></li>
          <li><a href="../../articles/composition.html">Composition Guide</a></li>
        </ul>
      </div>
      <div class="col col-sm-4">
        <h3><a href="../../articles/about.html">Policies</a></h3>
        <ul class="nav nav-pills nav-stacked">
          <li><a href="../../articles/about.html#assignments">Assignments</a></li>
          <li><a href="../../articles/about.html#exams">Exams</a></li>
          <li><a href="../../articles/about.html#grading">Grading</a></li>
        </ul>
      </div>
    </div>
  </footer>



  <script src="../../assets/js/sketchy.js"></script>
  <script>
    $('.sidebar ul').addClass('nav nav-stacked noselect');
    $('body').scrollspy({
      target: '.sidebar',
      offset: 40
    });

    function goToId(id) {
      var target = $(id);
      target.parent().show();
      $('html,body').animate({
        scrollTop: target.offset().top,
      }, 100);
      $("body").scrollspy('refresh');
    }

    if (location.hash) {
      setTimeout(function () {
        if (location.hash) {
          goToId(location.hash);
        }
      }, 1);
    }

    $("a").click(function (event) {
      var urlBeforeHashRegEx = new RegExp("^" + window.location.href.split("#")[0]);
      if (/^#/.test(this.hash) && urlBeforeHashRegEx.test(this.href)) {
        event.preventDefault();
        goToId(this.hash);
        document.location.hash = this.hash;
      }
    });
  </script>

</body>

</html>